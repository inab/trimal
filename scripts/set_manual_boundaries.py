#!/usr/bin/python

#
# 'set_manual_boundaries.py'
#
#   Script implemented to work with trimAl to analyze gaps statistics and decide
#   which are the boundaries in a given alignment - columns inbetween these
#   boundaries will not be removed independently of the trimming strategy
#   selected.
#
#   [2014] S. Capella-Gutierrez - scapella@crg.es
#
#   this script is free software: you can redistribute it and/or modify it under
#   the terms of the GNU General Public License as published by the Free
#   Software Foundation, the last available version.
#
#   this script is distributed in the hope that it will be useful, but WITHOUT
#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
#   more details on <http://www.gnu.org/licenses/>
#

import os
import sys
import argparse
import re

npos = 0
blockNum = 0
left = 0
right = -1
main_left = -1
main_right = -1


def main():

    parser = argparse.ArgumentParser()

    parser.add_argument("-i", "--input", dest="inFile", required=True,
                        type=str, help="Output file containing gaps stats generated by trimAl"
                        + " - option -sgc")

    parser.add_argument("--min_gapscore",
                        type=float, default=.8, help="Set the minimum gap score (1 - fraction"
                        + "of gaps) which we will use to set the boundaries when there are not "
                        + "two columns with no gaps - default 0.8")

    parser.add_argument("--get_best_boundaries", dest="bestBoundaries", default=False,
                        action="store_true", help="Get the best possible boundaries")

    parser.add_argument("--discard_nogaps_columns",
                        default=False, action="store_true", help="Discard those columns with "
                        + "no gaps - otherwise, those columns will be preferentially selected as "
                        + "boundaries - this parameter will be ignored if this column are the first"
                        + "/last one to pass the input gap_score threshold")

    parser.add_argument("--one_line", default=False, action="store_true", help="Generate output in just one line which will be used "
                        + "directly by trimAl")

    parser.add_argument("--inner_blocks", default=False,
                        action="store_true", help="Compute inner blocks")

    parser.add_argument("--min_block_size", type=float,
                        default=0, help="Set minimum block size in percentage of the "
                        + "alignment covered (1 = 100%")

    parser.add_argument("--max_blocks", type=int,
                        default=1000, help="Set maximum blocks to compute")

    parser.add_argument("--total_blocks", default=False,
                        action="store_true", help="Print only total number of blocks")

    parser.add_argument("--block_coordinates", default=False,
                        action="store_true", help="Print coordinates of main block")

    args = parser.parse_args()

    if not os.path.isfile(args.inFile):
        sys.exit("ERROR: The input file should be defined")

    if args.min_gapscore < 0 or args.min_gapscore > 1:
        sys.exit(
            "ERROR: --min_gapscore_allow should be defined in the range [0,1]")

    if args.min_block_size < 0 or args.min_block_size > 1:
        sys.exit(
            "ERROR: --min_block_size should be defined in the range [0,1]")

    if args.max_blocks < 1:
        sys.exit("ERROR: --max_blocks should at least 1")

    global left
    global right

    while compute_blocks(args.inFile, args.min_gapscore, args.discard_nogaps_columns, args.one_line, args.bestBoundaries,
                         args.total_blocks, args.min_block_size, args.inner_blocks, args.max_blocks) == -1:
        left += 1
        right -= 1

    if args.block_coordinates:
        print("## Left column ", main_left)
        print("## Right column ", main_right)

# ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ****


def compute_blocks(inFile, min_gapscore, discard_nogaps_columns, one_line, bestBoundaries, total_blocks, min_block_size, inner_blocks, max_blocks):
    global npos
    global blockNum
    global left
    global right
    global main_left
    global main_right
    global total_num_blocks

    putative = [0, 0, False, 0, 0]
    boundaries = [-1, -1, -1, -1, -1, -1]
    for line in open(inFile, "r"):
        # Discard any line containing text
        if not re.search('[0-9]', line[0]):
            continue

        f = [chunk for chunk in map(str.strip, line.split(" ")) if chunk]
        if not f:
            continue

        # Only count positions for the first block
        if blockNum == 0:
            npos += 1
        pos = int(f[0])
        gap_score = float(f[2])

        if pos < left:
            continue

        if right != -1 and pos > right:
            break

        # This function is intended to find columns - with at least one gap - which
        # will be used as left and right boundaries for trimAl
        if gap_score >= min_gapscore:

            # Check whether the left boundary is defined, if that the case, define
            # the right one
            if boundaries[0] != -1:
                # We update constantently the right boundary until the last best value
                # is found
                if gap_score != 1.0:
                    boundaries[3] = pos
                    boundaries[4] = gap_score

            # Define the left boundary as the first value passing the input threshold
            elif gap_score != 1.0:
                boundaries[0] = pos
                boundaries[1] = gap_score

            # Get the most to the right column without any gap
            if gap_score == 1.0:
                boundaries[5] = pos

            # Get the most to the left column without any gap
            if gap_score == 1.0 and boundaries[2] == -1:
                boundaries[2] = pos

        else:
            # Try to get the best potential cutting points below to the input
            # thresholds - it would be useful if we don't found the boundaries

            # We will update the right boundary constantly
            if gap_score > putative[4]:
                putative[4] = gap_score
                putative[3] = pos

            # We update current value until the left boundary is found
            if boundaries[0] == -1:

                # Any pick on values - reflected like the at least the double of the
                # current best value, should be store.
                if gap_score > (2 * putative[1]):
                    putative[1] = gap_score
                    putative[2] = False
                    putative[0] = pos

                # We update the left boundaries if and only if the immediate previous
                # position has at least a similar value
                if not putative[2] and gap_score >= putative[1]:
                    putative[1] = gap_score
                    putative[0] = pos
                else:
                    putative[2] = True

    output = ""
    left_ratio = right_ratio = 0
    # Generate output, if any

    # First try to get the best column possible - unless the user has set-up
    # specifically to discard them
    if boundaries[2] != boundaries[5] and not discard_nogaps_columns:
        left = boundaries[2]
        right = boundaries[5]
        left_ratio = float(left)/npos
        right_ratio = float(right)/npos
        output = no_gaps_output(one_line, left,
                                right, left_ratio, right_ratio)

    elif not output and boundaries[0] != boundaries[3]:

        # If columns with no gaps are the first/last ones found - select them as
        # the boundaries independently of user input parameters.
        left = boundaries[0]
        left_score = boundaries[1]
        if boundaries[2] != -1 and boundaries[2] < boundaries[0]:
            left = boundaries[2]
            left_score = 1.0

        right = boundaries[3]
        right_score = boundaries[4]
        if boundaries[5] != -1 and boundaries[5] > boundaries[3]:
            right = boundaries[5]
            right_score = 1.0

        left_ratio = float(left)/npos
        right_ratio = float(right)/npos
        output = best_gap_score_output(one_line, left, right, left_score,
                                       right_score, left_ratio, right_ratio)

    # If there is no output, and the user has set-up "--get_best_boundaries"
    elif not output and bestBoundaries:
        left = putative[0]
        left_score = putative[1]

        right = putative[3]
        right_score = putative[4]

        left_ratio = float(left)/npos
        right_ratio = float(right)/npos
        output = best_found_gap_score_output(one_line, left, right, left_score,
                                             right_score, left_ratio, right_ratio)

    # Generate a warning for those cases where no boundaries have been found
    if not output:
        if total_blocks:
            print_total_blocks(blockNum)
        else:
            print("WARNING: OUTPUT NOT AVAILABLE")
    else:
        # Ratio is defined with respect to the original alignment
        ratioDiff = right_ratio - left_ratio
        if ratioDiff < min_block_size:
            if blockNum == 0:
                print(("WARNING: OUTPUT NOT AVAILABLE. THE BLOCK SIZE COVERS LESS THAN "
                       + "THE %.4f%% OF THE ALIGNMENT") % (min_block_size))
            if total_blocks:
                print_total_blocks(blockNum)
        else:
            if not total_blocks:
                print(output)
            if blockNum == 0:
                main_left = left
                main_right = right
            blockNum += 1
            positionsDiff = right - left

            if not total_blocks:
                print(("## Block %d contains %d column(s) and "
                       + "%.4f%% of the alignment\n") % (blockNum, positionsDiff + 1, ratioDiff))
            if inner_blocks:
                if positionsDiff > 2 and blockNum < max_blocks:
                    return -1
                elif total_blocks:
                    print_total_blocks(blockNum)
            elif total_blocks:
                print_total_blocks(blockNum)

    return 0


def no_gaps_output(one_line, left, right, left_ratio, right_ratio):
    if not one_line:
        output = ("## %-30s\t1.0000\t") % ("NO Gaps Left Boundary")
        output += ("pos\t%d\t%%alig\t%.4f") % (left, left_ratio)
        output += ("\n## %-30s\t1.0000\t") % ("NO Gaps Right Boundary")
        output += ("pos\t%d\t%%alig\t%.4f") % (right, right_ratio)
    else:
        output = ("%d,%d") % (left, right)

    return output


def best_gap_score_output(one_line, left, right, left_score, right_score,
                          left_ratio, right_ratio):
    if not one_line:
        output = ("## %-30s\t") % ("Best Gaps_Score Left Boundary")
        output += ("%.4f\tpos\t%d\t%%alig\t%.4f\n") % (left_score,
                                                       left, left_ratio)
        output += ("## %-30s\t") % ("Best Gaps_Score Right Boundary")
        output += ("%.4f\tpos\t%d\t%%alig\t%.4f") % (right_score, right,
                                                     right_ratio)
    else:
        output = ("%d,%d") % (left, right)

    return output


def best_found_gap_score_output(one_line, left, right, left_score, right_score,
                                left_ratio, right_ratio):
    if not one_line:
        output = ("## %-30s\t") % ("Best_found Gaps_Score Left Boundary")
        output += ("%.4f\tpos\t%d\t%%alig\t%.4f\n") % (left_score,
                                                       left, left_ratio)
        output += ("## %-30s\t") % ("Best_found Gaps_Score Right Boundary")
        output += ("%.4f\tpos\t%d\t%%alig\t%.4f") % (right_score, right,
                                                     right_ratio)
    else:
        output = ("%d,%d") % (left, right)

    return output


def print_total_blocks(num_blocks):
    print("## Blocks ", num_blocks)


if __name__ == "__main__":
    sys.exit(main())
